---
title: 数据结构与算法绪论
permalink: 数据结构与算法绪论
date: 2019-04-29 23:39:35
categories: 
-   数据结构与算法
-   数据结构与算法绪论
tags: [数据结构, 算法, 算法复杂度]
description: 数据结构与算法（一）：数据结构的基本概念和算法的评估
---

<!--more-->

# 一、数据结构的基本概念
## 1.数据

数据是信息的载体，是描述客观事物属性的数、字符以及所有能够输入到计算机中并被计算机程序识别和处理的符号的集合。
## 2.数据元素

**数据元素是数据的基本单位**，通常作为一个整体进行考虑和处理。
一个数据元素可由若干个数据项组成，**数据项是构成数据元素的不可分割的最小单位。**
例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。

## 3.数据类型

**数据类型是一个值的集合和定义在此集合上一组操作的总称。**
	1）原子类型：其值不可再分的数据类型。
	2）结构类型：其值可以再分解为若干成分（分量）的数据类型。
	3） 抽象数据类型：抽象数据组织和与之相关的操作。
## 4.抽象数据类型
**抽象数据类型（ADT）是指一个数学模型以及定义在该模型上的一组操作。**

抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。

通常用（数据对象、 数据关系、 基本操作集）这样的三元组来表示抽象数据类型。

**数据对象是具有相同性质的数据元素的集合，是数据的一个子集**。例如，整数数据对象是集合N={0,±1,±2,…}。

## 5.数据结构
数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。
数据结构包括三方面的内容： 逻辑结构、存储结构和数据的运算。
数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。

### 5.1 逻辑结构

逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的数据的逻辑结构分为线性结构和非线性结构
  ![](/image/数据结构与算法绪论/01.PNG)
**集合** 结构中的数据元素之间除了“同属于一个集合” 的关系外， 别无其他关系。 类似于数学上的集合
**线性结构** 结构中的数据元素之间只存在一对一的关系。 比如排队
**树形结构** 结构中的数据元素之间存在一对多的关系。 比如家族族谱
**图状结构或网状结构** 结构中的数据元素之间存在多对多的关系。 比如地图

### 5.2 物理结构

存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。
数据的存储结构主要有： 顺序存储、链式存储、索引存储和散列存储。
* 顺序存储：
  存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）
  ![](/image/数据结构与算法绪论/02.PNG)
* 链接存储：
  存储的物理位置未必相邻，通过 记录相邻元素的物理位置来找到相邻元素。
  ![](/image/数据结构与算法绪论/03.PNG)
* 索引存储：
  类似于目录，以后可以联系操作系统的文件系统章节来理解。
* 散列存储：
  通过关键字直接计算出元素的物理地址（以后详解）。
### 5.3 数据的运算
数据的运算包括运算的定义和实现。

*   运算的定义是针对逻辑结构。

*   运算的实现是针对物理结构。



# 二、算法的定义与评估

## 1.算法定义

算法是对问题求解步骤的描述，通过有限序列的指令来实现

## 2.算法的五大特征

1，有穷性： 有限步之后结束
2，确定性：不存在二义性，即没有歧义
3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。
4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。
5，输出：一至多个程序输出结果。 

## 3. 算法的时间复杂度

### 3.1 定义

*   用来衡量算法随着问题规模增大，算法执行时间增长的快慢；

*   是问题规模的函数： T(n)是时间规模函数 时间复杂度主要分析$T(n)$的数量级

*   $T(n)=O(f(n)), f(n)$是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度

### 3.2 计算方法

*   取算法时间增长最快的那个函数项， 忽略它的系数；复杂度是关于增长率的，所以可以直接忽视常数项

*   一般可以直接关注循环段基本操作语句（示例中的sum=sum+i）的执行次数。 

*   常用的时间复杂度大小关系：
    $Ο(1)＜Ο(\log_{2}n)＜Ο(n)＜Ο(n\log_{2}n)＜Ο(n^2)＜Ο(n^3)＜Ο(2^n)$ 
    *   PS： $\log_{2}n$更多写成$\log{n}$
    *   从左至右，时间性能依次降低。 

## 4.算法的空间复杂度

*   空间复杂度S(n)指算法运行过程中所使用的辅助空间的大小。 
    *   辅助空间：除了存储算法本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。
    *   算法原地工作是指算法所需的辅助空间是常量，即O(1)。 

*   用来衡量算法随着问题规模增大，算法所需空间的快慢；

*   是问题规模的函数： $S(n)=O(g(n)) $；算法所需空间的增长率和$g(n)$的增长率相同。 

    

## 三、 时间复杂度的计算

### 1. 思路归纳

#### 1.1 直接计算型

*   例1：

~~~C++
for(i = n-1; i>1; i--)
	for(j=1; j<i; j++)
		if(A[j]>A[j+1])
			A[j]与A[j+1]互换
~~~

>   最差情况：每一次都执行交换语句
>
>   $T(n) = \sum^{n-1}_{i=2}\sum^{i-1}_{j=1}{1}=\sum^{n-1}_{i=2}{i-1}=\frac{(n-2)(n-1)}{2}=O(n^2)$

*   例2：

~~~C++
for(i=0; i<n; i++)
    for(j=0; j<i; j++)
        for(k=0; k<j; k++)
            x++;
~~~

>   $T(n) = O(\sum^{n}_{i=1}\sum^{i}_{j=1}\sum^{j}_{k=1}{1})=O(\frac{1}{6}n^3)=O(n^3)$



#### 1.2 引入变量

1） 设执行次数为$t$

2） 根据循环语句得到$执行次数t和问题规模n$的关系式$t \leq f(n)$

3） $T(n) = O(f(n))$

*   例1：

~~~C++
x = 2;
while(x<n/2)
    x = x*2;
~~~

>   设执行次数为$t$，则有$2^{t+1}<n/2$，即$t < \log_{2}{(n/2)}-1=\log_{2}{n}-2$，所以$T(n) = O(\log_{2}{n})$

*   例2：

~~~C++
y=0;
while((y+1)*(y+1)<=n)
    y = y+1;
~~~

>   设执行次数为$t$，则有$y = t$，可得$y^2 = t^2 \leq n$，所以$T(n) = O(n^{1/2})$

*   例3：

~~~C++
int func(int n){
    int i=0, sum=0;
    while(sum<n)
        sum += ++i;
    return i;
}
~~~

>   设执行次数为$t$，则$sum = (1+t)*t /2$，即$t/2+t^2/2 < n$，所以$T(n) = O(n^{1/2})$



#### 1.3 递归程序

*   例1：

~~~C++
int fact(int n){
    if(n<=1) return 1;
    return n*fact(n-1)
}
~~~

>   $T(n) = 1+T(n-1) = 1+1+T(n--2) = ... = n-1+T(1) = n$

*   例2：
    $$T(n) = \begin{cases}
    1, n=1\\
    2T(n/2)+n, n>1\\
    \end{cases}$$

    >   设$n = 2^k(k>=0)$， 则$T(n) = T(2^k) = 2 T(2^{k-1})+2^k  = 2^2 T(2^{k-2})+2*2^k$， 可得$T(2^k) = 2^k T(2^0)+k*2^k$， 即$T(n) = 2^{\log_{2}{n}}+n *\log_2{n} = n*(\log_2{n}+1)$， 所以$T(n) = O(n* \log_2{n})$

    

### 2. 参考公式

*   等差求和公式：

*   等比求和公式：

*   递推求和公式: